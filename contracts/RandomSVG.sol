// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "base64-sol/base64.sol";

// Declaring custom errors
error RandomSVG__NeedToSendMoreETH();
error RandomSVG__TokenIsAlreadySet();
error RandomSVG__TokenIdHasNotBeenMintedYet();
error RandomSVG__NeedToWaitForTheChainlinkNodeToResponed();
error RandomSVG__TransactionFailed();

/**

@title RandomSVG
@dev This contract creates and manages a collection of SVG NFTs. Each SVG is randomly generated from a set of path commands and colors.
The randomness is generated by Chainlink VRF.
*/
contract RandomSVG is ERC721URIStorage, VRFConsumerBaseV2, Ownable {
    /* Variables*/
    uint256 private s_tokenCounter; // Keeps track of the number of tokens that have been minted
    uint256 private s_mintFee; // The fee required to mint a token
    uint256 private immutable i_maxNumberOfPaths; // The maximum number of paths that can be generated for an SVG
    uint256 private immutable i_maxNumberOfPathCommands; // The maximum number of path commands that can be used in an SVG
    uint256 private immutable i_size; // The size of the SVG image
    string[] private s_pathCommands; // An array of path commands used to generate the SVG
    string[] private s_colors; // An array of colors used to generate the SVG

    // Chainlink VRF variables
    VRFCoordinatorV2Interface private immutable i_vrfCoordinatorV2; // The VRFCoordinatorV2 contract
    bytes32 private immutable i_gasLane; // The gas lane
    uint64 private immutable i_subscriptionId; // The subscription ID
    uint32 private immutable i_callbackGasLimit; // The gas limit for the callback function
    uint16 private constant REQUEST_CONFIRMATIONS = 3; // The number of confirmations required for a VRF request
    uint32 private constant NUM_WORDS = 1; // The number of random words to request from the VRF oracle

    // Mappings
    mapping(uint256 => address) private s_requestIdToSender; // Maps a request ID to the address of the sender
    mapping(uint256 => uint256) private s_requestIdToTokenId; // Maps a request ID to the ID of the token being minted
    mapping(uint256 => uint256) private s_tokenIdToRandomNumber; // Maps a token ID to the random number generated for it

    /* Events*/
    // Event triggered when a new SVG is requested
    event RequestedRandomSVG(
        uint256 indexed requestId,
        uint256 indexed tokenId
    );
    // Event triggered when an SVG is generated but not yet fully minted
    event CreatedUnfinishedRandomSVG(
        uint256 indexed tokenId,
        uint256 indexed randomNumber
    );
    event CreatedRandomSVG(uint256 indexed tokenId, string svg); // Event triggered when an SVG is fully minted and saved

    /* Functions*/
    /**
     * @dev Constructor of the contract. Initializes the contract with given values.
     * @param _vrfCoordinatorV2 The address of the VRFCoordinatorV2 contract
     * @param _gasLane The gas lane
     * @param _subscriptionId The subscription ID
     * @param _callbackGasLimit The gas limit for the callback function
     * @param _maxNumberOfPaths The maximum number of paths in an SVG
     * @param _maxNumberOfPathCommands The maximum number of path commands in an SVG
     * @param _size The size of the SVG canvas
     * @param _mintFee The fee required to mint a token
     */
    constructor(
        address _vrfCoordinatorV2,
        bytes32 _gasLane,
        uint64 _subscriptionId,
        uint32 _callbackGasLimit,
        uint256 _maxNumberOfPaths,
        uint256 _maxNumberOfPathCommands,
        uint256 _size,
        uint256 _mintFee
    ) ERC721("Random SVG NFT", "RSN") VRFConsumerBaseV2(_vrfCoordinatorV2) {
        i_vrfCoordinatorV2 = VRFCoordinatorV2Interface(_vrfCoordinatorV2);
        i_gasLane = _gasLane;
        i_subscriptionId = _subscriptionId;
        i_callbackGasLimit = _callbackGasLimit;
        s_tokenCounter = 0;
        i_maxNumberOfPaths = _maxNumberOfPaths;
        i_maxNumberOfPathCommands = _maxNumberOfPathCommands;
        i_size = _size;
        s_mintFee = _mintFee;
        s_pathCommands = ["M", "L"];
        s_colors = ["red", "blue", "green", "black", "white", "yellow"];
    }

    /**
     * @dev Sets the mint fee for the contract
     * @param _mintFee The new mint fee
     */

    function setMintFee(uint256 _mintFee) public onlyOwner {
        s_mintFee = _mintFee;
    }

    /**
     * @dev Creates a new NFT and sends a request to the VRFCoordinatorV2 contract for a random number
     * @return requestId The ID of the request sent to the VRFCoordinatorV2 contract
     */
    function create() public payable returns (uint256 requestId) {
        requestId = i_vrfCoordinatorV2.requestRandomWords(
            i_gasLane,
            i_subscriptionId,
            REQUEST_CONFIRMATIONS,
            i_callbackGasLimit,
            NUM_WORDS
        );
        if (msg.value < s_mintFee) {
            revert RandomSVG__NeedToSendMoreETH();
        }
        s_requestIdToSender[requestId] = msg.sender;
        uint256 tokenId = s_tokenCounter;
        s_requestIdToTokenId[requestId] = tokenId;
        s_tokenCounter += 1;
        emit RequestedRandomSVG(requestId, tokenId);
    }

    /**
     * @dev Callback function called by the VRFCoordinatorV2 contract when a random number is generated
     * @param _requestId The ID of the request sent to the VRFCoordinatorV2 contract
     * @param _randomWords An array of random numbers generated by the VRFCoordinatorV2 contract
     */
    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] memory _randomWords
    ) internal override {
        address nftOwner = s_requestIdToSender[_requestId];
        uint256 tokenId = s_requestIdToTokenId[_requestId];
        _safeMint(nftOwner, tokenId);
        uint256 randomNumber = _randomWords[0];
        s_tokenIdToRandomNumber[tokenId] = randomNumber;
        emit CreatedUnfinishedRandomSVG(tokenId, randomNumber);
    }

    /**
     * @dev Finishes minting the NFT by generating the SVG, converting it to an image URI and setting the token URI
     * @param _tokenId The ID of the token to be minted
     */

    function finishMint(uint256 _tokenId) public {
        if (bytes(tokenURI(_tokenId)).length > 0) {
            revert RandomSVG__TokenIsAlreadySet();
        }
        if (s_tokenCounter < _tokenId) {
            revert RandomSVG__TokenIdHasNotBeenMintedYet();
        }
        if (s_tokenIdToRandomNumber[_tokenId] < 0) {
            revert RandomSVG__NeedToWaitForTheChainlinkNodeToResponed();
        }

        uint256 randomNumber = s_tokenIdToRandomNumber[_tokenId];
        string memory svg = generateSVG(randomNumber);
        string memory imageURI = svgToImageURI(svg);
        string memory tokenURI = formatToTokenURI(imageURI);
        _setTokenURI(_tokenId, tokenURI);
        emit CreatedRandomSVG(_tokenId, svg);
    }

    /**
     * @dev Withdraws the contract balance to the owner's address
     * @notice Only the contract owner can call this function
     * @notice This function reverts if the transaction fails
     */
    function withdraw() public payable onlyOwner {
        uint256 amount = address(this).balance;
        (bool success, ) = msg.sender.call{value: amount}("");
        if (!success) {
            revert RandomSVG__TransactionFailed();
        }
    }

    /**
     * @dev Encodes an SVG string to a base64-encoded data URI with an SVG content type
     * @param _svg The SVG string to encode
     * @return The base64-encoded data URI with an SVG content type
     */
    function svgToImageURI(
        string memory _svg
    ) public pure returns (string memory) {
        string memory baseURL = "data:image/svg+xml;base64,";
        string memory svgBase64Encoded = Base64.encode(
            bytes(string(abi.encodePacked(_svg)))
        );
        return string(abi.encodePacked(baseURL, svgBase64Encoded));
    }

    /**
     * @dev Formats an image URI to a JSON token URI for the SVG NFT
     * @param _imageURI The image URI of the SVG NFT
     * @return The JSON token URI for the SVG NFT
     */
    function formatToTokenURI(
        string memory _imageURI
    ) public pure returns (string memory) {
        return
            string(
                abi.encodePacked(
                    "data:application/json;base64,",
                    Base64.encode(
                        bytes(
                            string(
                                abi.encodePacked(
                                    '{"name":" SVG NFT","description":"An NFT based on SVG!","attributes":"","image":"',
                                    _imageURI,
                                    '" }'
                                )
                            )
                        )
                    )
                )
            );
    }

    function generateSVG(
        uint256 _randomNumber
    ) public view returns (string memory finalSVG) {
        uint256 numberOfPaths = (_randomNumber % i_maxNumberOfPaths) + 1;
        finalSVG = string(
            abi.encodePacked(
                "<svg xmlns='http://www.w3.org/2000/svg' height='",
                uint2str(i_size),
                "' width='",
                uint2str(i_size),
                "'>"
            )
        );
        for (uint256 i = 0; i < numberOfPaths; i++) {
            string memory pathSVG = generatePath(
                uint256(keccak256(abi.encode(_randomNumber, i)))
            );
            finalSVG = string(abi.encodePacked(finalSVG, pathSVG));
        }
        finalSVG = string(abi.encodePacked(finalSVG, "</svg>"));
    }

    /**
     * @dev Generates an SVG with a given random number
     */
    function generatePath(
        uint256 _randomNumber
    ) public view returns (string memory PathSVG) {
        uint256 numberOfPathCommands = (_randomNumber %
            i_maxNumberOfPathCommands) + 1;
        PathSVG = "<path d='";
        for (uint256 i = 0; i < numberOfPathCommands; i++) {
            string memory pathCommand = generatePathCommands(
                uint256(keccak256(abi.encode(_randomNumber, i_size, i)))
            );
            PathSVG = string(abi.encodePacked(PathSVG, pathCommand));
        }
        string memory color = s_colors[_randomNumber % s_colors.length];
        PathSVG = string(
            abi.encodePacked(
                PathSVG,
                "' fill='transparent' stroke='",
                color,
                "'/>"
            )
        );
    }

    /**
     * @dev Generates a path with a given random number
     */
    function generatePathCommands(
        uint256 _randomNumber
    ) public view returns (string memory pathCommand) {
        pathCommand = s_pathCommands[_randomNumber % s_pathCommands.length];
        uint256 parameterOne = uint256(
            keccak256(abi.encode(_randomNumber, i_size * 2))
        ) % i_size;
        uint256 parameterTwo = uint256(
            keccak256(abi.encode(_randomNumber, i_size * 2 + 1))
        ) % i_size;
        pathCommand = string(
            abi.encodePacked(
                pathCommand,
                " ",
                uint2str(parameterOne),
                " ",
                uint2str(parameterTwo)
            )
        );
    }

    /**
    @dev Converts an unsigned integer to its string representation.
    @param _i The unsigned integer to convert.
    @return _uintAsString The string representation of the unsigned integer.
    */
    function uint2str(
        uint _i
    ) internal pure returns (string memory _uintAsString) {
        if (_i == 0) {
            return "0";
        }
        uint j = _i;
        uint len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len;
        while (_i != 0) {
            k = k - 1;
            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }

    function getTokenCounter() public view returns (uint256) {
        return s_tokenCounter;
    }

    function getMintFee() public view returns (uint256) {
        return s_mintFee;
    }

    function getMaxNumPaths() public view returns (uint256) {
        return i_maxNumberOfPaths;
    }

    function getNumOfPathCommand() public view returns (uint256) {
        return i_maxNumberOfPathCommands;
    }

    function getTokenId(uint256 _requestId) public view returns (uint256) {
        return s_requestIdToTokenId[_requestId];
    }
}
